---
title: 'Encrypt and decrypt data with "Orion" library in Rust'
excerpt: "Safely encrypt sensitive data has always been a delicate operation. Especially when using a single password to encrypt and decrypt the data. Some say that at this point you already lost or that you shouldn't do this at all. But sometimes there's no choice! Having to store Solana wallets and protecting it by a single password, I've had to use something that can do this for me."
coverImage: '/assets/blog/rust-encryption-1/lock.jpg'
date: '2022-05-12T12:35:07.322Z'
author:
  name: Anthony Manikhouth
  picture: '/assets/blog/authors/anthony.jpg'
ogImage:
  url: '/assets/blog/rust-encryption-1/lock.jpg'
---

## Storing sensitive data? Why?

At Symbiose, we're building an awesome app that will interact with multiple blockchains, thus requiring some reflexion about one of the core element of a blockchain, the wallet and specificaly its storing logic.

Let's take the example of the Solana blockchain. A Solana wallet is represented by a Keypair object, which is a pair of public and private keys.

`solana-cli` is a command line interface for the Solana blockchain, that allows you to generate a new wallet, or to import a wallet from a file. It uses simple JSON files to store the generated keypairs, saving the **unencrypted** private key as a `u8` array in the file. To retrieve it back, the cli derives the public key from the private key and then uses `Keypair::from_bytes` to create a new Keypair object.

While this method is simple and fast, `solana-cli` stores this data as plaintext and anyone gaining access to the machine could easily fetch the keypairs.

```shell
# A key is often generated like this...
solana-keygen new --outfile ~/.config/solana/keypairs/default.json
# ... And an attacker could easily reads its contents like this.
cat ~/.config/solana/keypairs/default.json
```

## So what can we do to prevent this?
A solution is to encrypt the private key with an [AEAD algorithm](https://en.wikipedia.org/wiki/Authenticated_encryption) and store it wherever you want.

One of the safest way to do this today is to use the [ChaCha20](https://en.wikipedia.org/wiki/ChaCha20) and [Poly1305](https://en.wikipedia.org/wiki/Poly1305) algorithms ([RFC8439](https://datatracker.ietf.org/doc/html/rfc8439)).

To achieve this, we will need to use the [`orion`](https://docs.rs/orion/latest/orion/) library which offers a good `aead` module using XChaCha20Poly1305.

## Encrypting data with the `orion` library
First of all, a *Secret Key* is needed to encrypt the data. This key will be generated by deriving a combinaison of our plaintext password and a random salt.

Let's start by creating a new `orion::kdf::Password` object.
```rust
use orion::hazardous::stream::chacha20::CHACHA_KEYSIZE;
use orion::kdf::{derive_key, Password, Salt};
let password = Password::from_slice(password.as_bytes()).with_context(|| "Password error")?;
```
  
Then, we can derive the *Secret Key* from the password and the salt. But how do you get it?
```rust
pub fn nonce() -> Result<[u8; 24]> {
    let mut result = [0u8; 24];
    getrandom::getrandom(&mut result)?;
    Ok(result)
}
```

Yay, now that we have a nonce. Let's derive the secret key.
```rust
let salt = Salt::from_slice(salt).with_context(|| "Salt is too short")?;
let kdf_key = derive_key(&password, &salt, 15, 1024, CHACHA_KEYSIZE as u32)
    .with_context(|| "Could not derive key from password")?;
```

And finally get the *Secret Key* from the `kdf_key` object.
```rust
let key = SecretKey::from_slice(kdf_key.unprotected_as_bytes())
    .with_context(|| "Could not convert key")?;
```



Nice, we have our *Secret Key*! Now let's use it to encrypt our data.

These are the struct and functions we need to use to encrypt our data.
```rust
use orion::hazardous::{
    aead::xchacha20poly1305::{seal, Nonce, SecretKey as XSecretKey},
    mac::poly1305::POLY1305_OUTSIZE,
    stream::xchacha20::XCHACHA_NONCESIZE,
};
```

Let's use the function we just created to encrypt to retrieve a SecretKey object.
```rust
let key = get_key_from_password(password, nonce)?;
let key = XSecretKey::from_slice(key.unprotected_as_bytes()).with_context(|| "Key is invalid")?;
```

Alright! Now that we have our SecretKey object, we can prepare the output buffer for the encrypted data.

```rust
let nonce = Nonce::from_slice(nonce).with_context(|| "Nonce is too short")?;
// Get the output length
let output_len = match plaintext.len().checked_add(XCHACHA_NONCESIZE + POLY1305_OUTSIZE) {
    Some(min_output_len) => min_output_len,
    None => bail!("Plaintext is too long"),
};
// Allocate a buffer for the output
let mut output = vec![0u8; output_len];
output[..XCHACHA_NONCESIZE].copy_from_slice(nonce.as_ref());
```

And finally, store the encrypted data inside `output`:
```rust
seal(&key, &nonce, plaintext, None, &mut output[XCHACHA_NONCESIZE..])
    .with_context(|| "Could not convert key")?;
```

VoilÃ ! 

## Decrypting data with the `orion` library
Primarily, let's check that the data is valid.

```rust
use orion::aead::open;
use orion::hazardous::stream::xchacha20::XCHACHA_NONCESIZE;
ensure!(ciphertext.len() > XCHACHA_NONCESIZE, "Ciphertext is too short");
```

Now get the Secret Key to decrypt the ciphertext.

```rust
let key = get_key_from_password(password, &ciphertext[..XCHACHA_NONCESIZE])?;
open(&key, ciphertext).with_context(|| "Ciphertext was tampered with")
```


----------------------

The full source code can be found [here](https://gist.github.com/azerpas/b0820999293ec4c1b5e0dc6f66f1f545)
